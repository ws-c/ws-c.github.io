---
title: JavaScript-作用域
tags: [JavaScript]
categories: [JavaScript]
---
## 作用域  (scope)



### 局部作用域

- ​	局部作用域分成==函数作用域和块作用域==



#### 函数作用域:

​	在函数内部声明的变量只能在函数内部访问



> 总结:
>
> 1.函数内部声明的变量，在函数外部无法被访问
>
> 2.函数的参数也是函数内部的局部变量
>
> 3.不同函数内部声明的变量无法互相访问
>
> 4.函数执行完毕后，函数内部的变量实际被清空了



#### 块作用域

​	使用{ } 包裹的代码称为代码块



> 总结:
>
> 1.let声明的变量会产生块作用域，var不会产生块作用域
>
> 2.const声明的常量也会产生块作用域
>
> 3.不同代码块之间的变量无法互相访问
>
> 4.推荐使用let或const 



### 全局作用域

<script>标签和.js文件 就是全局作用域

在全局作用域中声明的变量，其他作用域都可以访问

 

### 作用域链

作用域链本质上就是底层的==变量查找机制==



​	在函数被执行时，会优先在当前函数作用域中查找变量

​	如果当前作用域查找不到就会依次逐级查找父级作用域直到全局作用域



> 总结:
> 1.嵌套关系的作用域串联起来形成了作用域链
> 2.相同作用域链中按着从小到大的规则查找变量
> 3.子作用域能够访问父作用域，父级作用域无法访问子级作用域



## JS垃圾回收机制

Garbage Collection 简称 GC

 	JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收机制自动回收



什么是内存泄漏？

​	不再使用的内存，没有及时释放，就叫做内存泄漏



### 内存的生命周期

1. 内存分配：当我们声明变量，函数，对象的时候，系统会自动为它们分配内存

2. 内存使用：即读写内存，也就是使用变量，函数等

3. 内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存

   

> 说明:
> 全局变量一般不会回收(关闭页面会回收)
> 一般情况下局部变量的值,不用了,会被自动回收掉



### 垃圾回收算法

#### 引用计数法

IE采用的算法，定义内存不再使用的标准就是看一个对象是否有指向它的引用

算法:

1. 跟踪记录每个值被引用的次数
2. 如果这个值的被引用了一次，那么就记录次数1
3. 多次引用会累加
4. 如果减少一个引用就减1
5. 如果引用次数是0，则释放内存



缺点：==嵌套引用==

​	如果两个对象互相引用，尽管不再使用，垃圾回收器也不会进行回收，导致内存泄漏

#### 标记清除法

现代的浏览器大多都是基于标记清除算法的某些改进算法，总体思想都是一致的

核心:

1. 标记清除算法将“不再使用的对象”定义为“无法达到的对象”
2. 就是从根部 (在JS中就是全局对象)出发定时扫描内存中的对象,凡是能从根部到达的对象，都是还需要使用的
3. 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收



## 闭包 (closure)

闭包 = ==内层函数 + 外层函数的变量== 

作用：封闭数据，提供操作，外部也可以访问函数内部的变量

~~~javascript
function outer() {
    let i = 1
    function fn () {
        console.log(i)
    }
    return fn
}
const fun = outer()
fun()
~~~

可能引发的问题：

​	内存泄漏  (全局变量)



## 变量提升

只存在var

变量提升到当前作用域的最前面，==只提升声明，不提升赋值==

~~~javascript
//var num    
console.log(num )	//undefined
var num =10
~~~



## 函数提升

​	把所有函数提升到当前作用域的最前面

​	==只提升函数声明，不提升函数调用==



- [x] 函数表达式不存在提升的现象



## 函数参数

### 动态参数（arguments）

arguments 只存在函数里面，是一个伪数组

~~~javascript
 function a(){
      let sum = 0
      for(let i=0;i<arguments.length;i++){
        sum += arguments[i]
      }
      return sum
    }
   console.log(a(23,2)) //返回25 可以传任意个参数
~~~

### 剩余参数

用于获取多余的实参,是一个真数组

~~~javascript
function getSum(a,b, ...arr) {
    console.log(arr)
}
getSum(1,2)	// []
getSum(1,2,3,4,5) // [3, 4, 5]
~~~

扩展：展开运算符  ( 可以把数组展开 )

~~~javascript
let arr = [1,2,3]
console.log(...arr) // 1,2,3
// 求数组最大值
console.log(Math.max(...arr) ) // 3  
// 合并数组
const arr2 = [4,5]
const arr = [...arr, ...arr2] //[1,2,3,4,5]
~~~



## ==箭头函数==

目的： 更简短的函数写法并且不绑定this，箭头函数的语法比函数表达式更简洁

使用场景：更适用于那些本来需要匿名函数的地方

箭头函数属于表达式函数， 因此不存在函数提升

~~~javascript
const fn = x => {    //只有一个形参的时候可以省略小括号
    console.log(x)
}
fn(1)
//只有一行代码的时候可以省略大括号, 并且不用写return 直接返回值
const fn = x => x + x 
fn(1)  //2
//可以直接返回一个对象
const fn = uname => ({uname: uname})
console.log(fn('小华'))
~~~

箭头函数的参数

​	只有剩余参数，没有动态参数（arguments)



箭头函数的 this

​	不会创建自己的this，只会从自己的作用域链的上一层找this

~~~javascript
btn.addEventListener('click', () => {
    console.log(this) //windows
})
~~~



## ==解构赋值==

### 数组解构

​	将数组的单元值快速批量赋值给一系列变量的简化语法

~~~javascript
let a = 1
let b = 2;
[b, a] = [a, b] //2 1
~~~

JS必须加分号的两种情况

​	立即执行函数，解构赋值



变量大于单元值 多出的变量为undefined

遇到变量少， 单元值多的情况  

~~~javascript
const[a,b ...arr] = [1,2,3,4]
console.log(arr) //[3, 4]
~~~



可以按需导入赋值

~~~javascript
const [a, ,b] = [1,2,3]
~~~



多维数组

~~~javascript
const [a, b, [c, d]] =[1,2,[3,4]]
~~~

### 对象解构

​	将对象属性和方法快速批量赋值给一系列变量的简化语法

~~~javascript
const obj = {
    name: '小王',
    age: 18
}
const {name, age} = obj
// 变量名和属性名必须一致, 但可以重新改名
const {name: username, age} = obj
//旧变量名 : 新变量名
~~~

多级对象结构

~~~javascript
const pig ={
    name: '佩奇',
    family: {
        mother: '猪爸爸',
        father: '猪妈妈',
    }, 
    age: 6
}
const {name, family: {mother, father}} = pig
~~~

